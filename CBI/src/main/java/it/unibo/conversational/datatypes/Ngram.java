package it.unibo.conversational.datatypes;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

import org.apache.commons.lang3.tuple.Pair;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;

import it.unibo.conversational.Utils;
import it.unibo.conversational.Utils.DataType;
import it.unibo.conversational.algorithms.Parser.Type;

/**
  * An ngram (a list of tokens).
  */
public final class Ngram {
  /** Concatenated tokens. Aggregation ngrams have no value. */
  public final String tokens;
  /** Similarity to the synonym. */
  private final Optional<Double> similarity;
  /** Synonym used to reach the element. */
  private final Optional<String> synonym;
  /** Ngram type. */
  public final Type type;
  /** Children. Tokens have no children. */
  public ImmutableList<Ngram> children;
  private final Optional<Entity> mdElement;
  private final Optional<Pair<Integer, Integer>> posInPhrase;

  /**
   * @return mapping to element in the datawarehouse
   */
  public Entity mde() {
    return mdElement.get();
  }

  /**
   * @return token position in sentence
   */
  public Pair<Integer, Integer> pos() {
    return posInPhrase.get();
  }


  public Ngram(String value, Type type, Entity entity, final Double sim, Pair<Integer, Integer> of) {
    this(value, type, entity, sim, null, of);
  }

  public Ngram(String value, Type bin, Entity entity, Pair<Integer, Integer> of) {
    this(value, bin, entity, 1.0, null, of);
  }

  /**
   * Leaf ngram.
   * @param value textual token(s)
   * @param type type of the ngram
   * @param mappingToMde reference to the multi dimensional element
   * @param pos begin/end positions
   */
  public Ngram(final String value, final Type type, final Entity mappingToMde, final Double similarity, final String synonym, final Pair<Integer, Integer> pos) {
    this(value, type, Lists.newArrayList(), mappingToMde == null ? Optional.empty() : Optional.of(mappingToMde), Optional.of(similarity),
        synonym == null ? Optional.empty() : Optional.of(synonym), pos == null ? Optional.empty() : Optional.of(pos));
  }

  /**
   * Aggregated ngram generated by the grammar.
   * @param type type of the ngram
   * @param children aggregated children
   */
  public Ngram(final Type type, final List<Ngram> children) {
    this("", type, children, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
  }

  /**
   * @param value tokens
   * @param type type of the ngram
   * @param children list of children
   * @param mde reference to the database entry
   * @param pos position
   */
  private Ngram(final String value, final Type type, final List<Ngram> children, final Optional<Entity> mde, final Optional<Double> similarity, final Optional<String> synonym, final Optional<Pair<Integer, Integer>> pos) {
    this.tokens = value;
    this.type = type;
    if (type.equals(Type.Q)) {
      this.children = ImmutableList.copyOf(children.stream().sorted((n1, n2) -> n1.type.compareTo(n2.type)).collect(Collectors.toList()));
    } else {
      this.children = ImmutableList.copyOf(children);
    }
    this.mdElement = mde;
    this.posInPhrase = pos;
    this.similarity = similarity;
    this.synonym = synonym;
  }

  /**
   * Return the ngram as a string tree parsable by zhsh. Removes `_` from string.
   * @return string tree parsable by zhsh.
   */
  public String toStringTree() {
    return (children.isEmpty() ? ((type.equals(Type.VAL) ? "v" : "") +  mde().nameInTable()) : type + "(" + children.stream().map((Ngram n) -> n.toStringTree()).reduce((n1, n2) -> n1 + " " + n2).get() + ")")
        .replace("_", "") // Tree distance breaks when _ = > < are in the string
        .replace("=", "e")
        .replace(">", "g")
        .replace("<", "l")
        .replace("!", "not");
  }

  /**
   * @return the average similarity
   */
  public Double similarity() {
    return mdElement.isPresent() ? similarity.get() : leaves(this).stream().mapToDouble(n -> ((Ngram) n).similarity()).average().getAsDouble();
  }

  /**
   * @return the minimum similarity
   */
  public Double minSimilarity() {
    return mdElement.isPresent() ? similarity.get() : leaves(this).stream().mapToDouble(n -> ((Ngram) n).similarity()).min().getAsDouble();
  }

  /**
   * Count the children nodes recursively.
   * @return number of nested node (plus self)
   */
  public int countNode() {
    int s = 1;
    for (final Ngram c : children) {
      if (!c.children.isEmpty()) {
        s += c.countNode();
      } else {
        s++;
      }
    }
    return s;
  }

  /**
   * Get lowest-level clauses.
   * @param ngram current ngram
   * @return ngram leaves
   */
  public static Set<Ngram> simpleClauses(final Ngram ngram) {
    final Set<Ngram> clauses = Sets.newLinkedHashSet();
    simpleClauses(ngram, clauses);
    return clauses;
  }

  /**
   * Return the smallest ngram clauses. I.e., the clauses that contains leaves.
   * @param stream current elements
   * @return smallest ngram clauses
   */
  private static void simpleClauses(final Ngram n, final Set<Ngram> acc) {
    if (!n.children.isEmpty() && n.children.stream().flatMap(c -> c.children.stream()).count() == 0) {
      acc.add(n);
    } else if (!n.children.isEmpty()) {
      n.children.forEach(c -> simpleClauses(c, acc));
    }
  }

  /**
   * Get the ngram leaves.
   * @param ngram current elements
   * @return ngram leaves
   */
  public static Set<Ngram> leaves(final Ngram ngram) {
    final Set<Ngram> leaves = Sets.newLinkedHashSet();
    leaves(ngram, leaves);
    return leaves;
  }

  /**
   * Get the ngram leaves.
   * @param n current element
   * @param acc accumulator
   */
  public static void leaves(final Ngram n, final Set<Ngram> acc) {
    if (n.children.isEmpty()) {
      acc.add(n);
    } else {
      n.children.forEach(c -> leaves(c, acc));
    }
  }

  @Override
  public String toString() {
    if (children.isEmpty()) {
      return "{\"type\":\"" + type // type
          + "\",\"token\":\"" + tokens + (posInPhrase.isPresent() ? " " + pos() : "") + "\"" // token with position
          + (mdElement.isPresent() ? ",\"mde\":" + mde().toString() : "")
          + (synonym.isPresent() ? ",\"syn\":\"" + synonym.get() + "\",\"sim\":" + Utils.DF.format(similarity()) : "")
          + "}";
    }
    return "{\"" + type + "\":" + children + "}";
  }

  @Override
  public boolean equals(final Object obj) {
    if (obj instanceof Ngram) {
      final Ngram n = (Ngram) obj;
          return type.equals(n.type) // with the same type 
              && tokens.equals(n.tokens) // and value
              && children.equals(n.children) // and children
              && mdElement.equals(n.mdElement) // and if they refer to the same md-element
              && posInPhrase.equals(n.posInPhrase)
              && synonym.equals(n.synonym)
              && Math.abs(similarity.orElse(0.0) - n.similarity.orElse(0.0)) < 0.001;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(type, tokens, children, mdElement, posInPhrase);
  }

  /**
   * Compare ngrams by position.
   * @param o1 an ngram
   * @param o2 another ngram
   * @return ngram comparison
   */
  public static int compareNgrams(final Ngram o1, final Ngram o2) {
    final int s = o1.pos().getLeft().compareTo(o2.pos().getLeft());
    if (s == 0) { // same start
      final int e = o1.pos().getRight().compareTo(o2.pos().getRight());
      if (e == 0) { // same end
        return -Double.compare(o1.similarity(), o1.similarity()); // sort by similarity desc
      }
      return e;
    }
    return s;
  }

  /** Type of errors and ambiguities. */
  public enum ErrorType {
    /** Operator cannot be applied to the given measure. */
    MDMV,
    /** Group by on descriptive attribute. */
    MDMG,
    /** Several measure can be inferred for the given measure. */
    MA,
    /** Several attributes can be inferred for the given member. */
    AA,
    /** Dom(L) != Dom(Member). */
    AVM
  }

  private final Map<ErrorType, Set<Entity>> annotations = Maps.newLinkedHashMap();
  /**
   * Add an annotation to this ngram.
   * @param error error type
   */
  public void annotate(final ErrorType error, final Set<Entity> validEntities) {
    annotations.put(error, validEntities);
  }

  /**
   * Update the children of the ngram. Used in the expand function.
   * @param children new children
   */
  public void setChildren(final ImmutableList<Ngram> children) {
    this.children = children;
  }

  /**
   * @return type of the mdelement in the database.
   */
  public DataType typeInDB() {
    return mde().getTypeInDB();
  }

  /**
   * @return annotations used for disambiguation
   */
  public Map<ErrorType, Set<Entity>> getAnnotations() {
    return annotations;
  }
}

